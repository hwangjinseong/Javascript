### 객체

- 객체형은 원시형과 달리 다양한 데이터를 담을 수 있습니다.
- 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있죠.
- 객체는 중괄호 {…}를 이용해 만들 수 있습니다.
- 중괄호 안에는 ‘키(key): 값(value)’ 쌍으로 구성된 프로퍼티(property)라고 한다.

### 원시 값

- 일곱 개는 오직 하나의 데이터(문자열, 숫자 등)만 담을 수 있어 '원시형(primitive type)'이라 부릅니다.

### 생성자보다 리터럴이 나은 이유

- 리터럴이 더 짧고 간결함
- new 생성자 함수가 클래스 기반 언어의 생성자와 문법이 같기 때문에 오해가 발생하기 쉽습니다

```jsx
let user = new Object(); // '객체 생성자' 문법
let user = {};  // '객체 리터럴' 문법
```

**리터럴** : 스크립트에 부여한 고정값으로, 변수가 아닙니다.

let user = {
name: "John",
age: 30,
"likes birds": true  // 복수의 단어는 따옴표로 묶어야 합니다.
};
여러 단어를 조합해 프로퍼티 이름을 만든 경우엔 프로퍼티 이름을 따옴표로 묶어줘야 합니다.

**상수 객체는 수정될 수 있습니다.**

```jsx
const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
```

### 점, **대괄호 표기법**

- 점 표기법: `obj.property`
- 대괄호 표기법 `obj["property"]`. 대괄호 표기법을 사용하면 `obj[varWithKey]`같이 변수에서 키를 가져올 수 있습니다.

### 객체엔 다음과 같은 추가 연산자를 사용할 수 있습니다.

- 프로퍼티를 삭제하고 싶을 때: `delete obj.prop`
- 해당 key를 가진 프로퍼티가 객체 내에 있는지 확인하고자 할 때: `"key" in obj`
- 프로퍼티를 나열할 때: `for (let key in obj)`

## 참조에 의한 객체 복사

**참조**는 객체의 실제 위치를 가리키는 포인터이다.

객체와 원시 타입의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사된다는 것입니다.

원시값(문자열, 숫자, 불린 값)은 ‘값 그대로’ 저장·할당되고 복사되는 반면에 말이죠.

```jsx
let message = "Hello!";
let phrase = message;
```

예시를 실행하면 두 개의 독립된 변수에 각각 문자열 `"Hello!"`가 저장됩니다.

**변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 '메모리 주소’인 객체에 대한 '참조 값’이 저장됩니다.(각각 변수에 값이 들어간다.)**

### 참조 값이란?

- 참조 값은 **변경 가능한 값**이다.
- 참조 값을 변수에 할당하면 변수에는 참조 값이 저장된다.

**객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않습니다**

### 변경 가능한 값의 의미

참조 값을 할당한 변수는 객체가 저장된 메모리 공간의 주소가 할당된다. 이 값을 **참조 값**이라 한다.예제와 그림을 보자

```
let student ={
  name:'Heo'
}
student.name = 'lee'
```

변수는 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장되죠.